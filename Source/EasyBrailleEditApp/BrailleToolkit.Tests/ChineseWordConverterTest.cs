// The following code was generated by Microsoft Visual Studio 2005.
// The test owner should check each test for validity.
using System.Collections.Generic;
using System.Linq;
using BrailleToolkit;
using BrailleToolkit.Converters;
using Huanlin.Common.Helpers;
using NChinese.Phonetic;
using Xunit;

namespace BrailleToolkit.Tests
{
    /// <summary>
    ///This is a test class for BrailleToolkit.ChineseWordConverter and is intended
    ///to contain all BrailleToolkit.ChineseWordConverter Unit Tests
    ///</summary>
    public class ChineseWordConverterTest
	{
        public ChineseWordConverterTest()
        {
            Shared.SetupLogger();
        }

        /// <summary>
        ///A test for Convert (Stack&lt;char&gt;, BrailleWord)
        ///</summary>
        [Theory]
        [InlineData("我", "　ㄨㄛˇ", "1208")]     // 測試結合韻。
        [InlineData("智", "ㄓ　　ˋ", "013110")]   // 測試單音字：要在音調記號前加一個空方。
        [InlineData("你", "ㄋㄧ　ˇ", "1D2108")]   // 測試無特殊規則的注音。
        [InlineData("：", "　　　ˉ", "1212")]     // 測試標點符號。
        [InlineData("　", "　　　ˉ", "00")]       // 測試全形空白。
        [InlineData("实", "ㄕ　　ˊ", "0A3102")]   // 測試簡體字。
        public void Should_ConvertSingleWord_Succeed(string text, string phCode, string brCode)
		{
            var processor = BrailleProcessor.CreateInstance();
            var target = new ChineseWordConverter(processor);

			ContextTagManager context = new ContextTagManager();
		
			Stack<char> charStack = new Stack<char>(text);
			List<BrailleWord> expected = new List<BrailleWord>();
            BrailleWord brWord = new BrailleWord(text, phCode, brCode);
            expected.Add(brWord);
			List<BrailleWord> actual = target.Convert(charStack, context);
            
			Assert.Equal(expected, actual);
        }

        [Theory]
        [InlineData("斜", "　ㄨㄛˇ", "1208")]
        public void Should_ConvertWithPhrase_Succeed(string text, string phCode, string brCode)
        {
            ZhuyinPhraseTable.GetInstance().AddPhrase("斜 ㄨㄛˇ");

            var processor = BrailleProcessor.CreateInstance();
            var target = new ChineseWordConverter(processor);

            ContextTagManager context = new ContextTagManager();

            Stack<char> charStack = new Stack<char>(text);
            List<BrailleWord> expected = new List<BrailleWord>();
            BrailleWord brWord = new BrailleWord(text, phCode, brCode);
            expected.Add(brWord);
            List<BrailleWord> actual = target.Convert(charStack, context);

            Assert.Equal(expected, actual);
        }



        [Theory]
        [InlineData("／")]   // 測試無法轉換的字元：/
        public void Should_ConvertInvalidWord_Fail(string text)
        {
            var processor = BrailleProcessor.CreateInstance();
            var target = new ChineseWordConverter(processor);

            ContextTagManager context = new ContextTagManager();

            var charStack = new Stack<char>(text);
            List<BrailleWord> actual = target.Convert(charStack, context);
            Assert.Null(actual);
        }

        public static IEnumerable<object[]> TestData1 =>
            new List<object[]>
            {
                new object[]
                {
                    // 測試句號接右括弧，兩者中間不可加空方；以及右括弧右邊接標點符號時，中間也不加空方。
                    "（氣象局。）。",
                    new List<BrailleWord>
                    {
                        new BrailleWord("（", "", "2A"),
                        new BrailleWord("氣", "ㄑㄧ　ˋ", "1A2110"),
                        new BrailleWord("象", "ㄒㄧㄤˋ", "112810"),
                        new BrailleWord("局", "ㄐㄩ　ˊ", "053302"),
                        new BrailleWord("。", "", "24"),
                        new BrailleWord("）", "", "15"),
                        new BrailleWord("。", "", "24")
                    }
                },
                new object[]
                {
                    "（太棒了！）",       // 測試驚嘆號接右括弧，兩者中間不可加空方。
                    new List<BrailleWord>
                    {
                        new BrailleWord("（", "", "2A"),
                        new BrailleWord("太", "ㄊ　ㄞˋ", "0B3A10"),
                        new BrailleWord("棒", "ㄅ　ㄤˋ", "152D10"),
                        new BrailleWord("了", "ㄌ　ㄜ˙", "092E01"),
                        new BrailleWord("！", "", "07"),
                        new BrailleWord("）", "", "15")
                    }
                },
                new object[]
                {
                    "（什麼？）",       // 測試問號接右括弧，兩者中間不可加空方。
                    new List<BrailleWord>
                    {
                        new BrailleWord("（", "", "2A"),
                        new BrailleWord("什", "ㄕ　ㄣˊ", "0A2502"),
                        new BrailleWord("麼", "ㄇ　ㄜ˙", "0D2E01"),
                        new BrailleWord("？", "", "15"),
                        new BrailleWord("）", "", "15")
                    }
                }
            };

        [Theory]
        [MemberData(nameof(TestData1))]
        public void Should_NoSpaceBetweenPunctuationAndParenthese(string input, List<BrailleWord> expected)
        {
            var processor = BrailleProcessor.CreateInstance();
            var target = new ChineseWordConverter(processor);

            ContextTagManager context = new ContextTagManager();
            var charStack = new Stack<char>(StrHelper.Reverse(input));
            List<BrailleWord> actual = target.Convert(charStack, context);

            Assert.Equal(expected, actual);
        }


        [Theory]
        [InlineData("─")]     // 0x2500
        [InlineData("──")]    // 兩個 0x2500
        [InlineData("－－")]   // 兩個 0xff0d
        [InlineData("——")]    // 兩個 0x2014
        public void Should_ConvertAllKindsOfEmdashes(string inputText)
        {
            var processor = BrailleProcessor.CreateInstance();
            var target = new ChineseWordConverter(processor);

            ContextTagManager context = new ContextTagManager();

            var charStack = new Stack<char>(inputText);
            List<BrailleWord> actual = target.Convert(charStack, context);
            Assert.NotNull(actual);
            Assert.Single(actual);

            Assert.Equal("(5 2)", actual[0].ToPositionNumberString(true));
        }

    }


}